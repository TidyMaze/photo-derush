#!/usr/bin/env bash
# Launch python under lldb, set environment and run args, capture backtrace when it crashes.
# Usage: ./scripts/lldb_capture.bt <output-log>

OUT_LOG=${1:-logs/lldb-capture.log}
PY="$PWD/.venv/bin/python3"
APP_ARGS=(app.py --log-file logs/qt-run-lldb-yolov8.log)

cat > /tmp/lldb_cmds.txt <<'LLDBCMDS'
settings set target.env-vars OMP_NUM_THREADS=1 MKL_NUM_THREADS=1 OPENBLAS_NUM_THREADS=1 VECLIB_MAXIMUM_THREADS=1 DETECTION_BACKEND=yolov8 DETECTION_DEVICE=cpu
settings set target.run-args -- app.py --log-file logs/qt-run-lldb-yolov8.log
# Ensure lldb stops and prints on SIGSEGV (EXC_BAD_ACCESS)
process handle SIGSEGV -p true -s true -n true
run
# Let the process continue until it crashes or exits
process continue
# When stopped (on crash), collect diagnostics
bt all
thread info
image list -v
register read
disassemble -s $pc -c 40
process status
quit
LLDBCMDS

mkdir -p "$(dirname "$OUT_LOG")"
echo "Running lldb non-interactively, output -> $OUT_LOG"
lldb --batch -s /tmp/lldb_cmds.txt -- "$PY" "${APP_ARGS[@]}" &> "$OUT_LOG" || true
echo "lldb finished (exit $?); output in $OUT_LOG"
